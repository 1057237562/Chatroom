<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI Chatroom</title>
    <link rel="stylesheet" href="/static/metro.css">
    <link rel="stylesheet" href="/static/voip.css">
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="tile tile-primary" id="userListTile">
                <h3>Users</h3>
                <div class="user-list-container">
                    <div id="userList"></div>
                </div>
            </div>
            <div class="tile tile-secondary" id="historyTile">
                <h3>History</h3>
                <div class="history-controls">
                    <input type="text" id="historySearch" placeholder="Search messages..." />
                    <input type="text" id="historyFilter" placeholder="Filter by user..." />
                    <button class="btn-small" id="loadHistoryBtn">Load History</button>
                </div>
                <div class="history-container">
                    <div id="historyList"></div>
                    <div id="historyLoading" style="display:none; text-align:center; padding:10px;">
                        Loading...
                    </div>
                </div>
            </div>
        </div>
        <div class="main">
            <div class="chat-container">
                <div class="tile tile-primary" id="chatTile">
                    <div class="chat-header">
                        <h3>Chat</h3>
                    </div>
                    <div class="chat-messages" id="messages"></div>
                </div>
                <div class="tile tile-secondary" id="inputArea">
                    <div class="textarea-wrapper">
                        <input type="text" id="username" placeholder="Enter Username" />
                        <textarea id="input" placeholder="Type a message... (Press Ctrl+Enter to send, Enter for new line)"></textarea>
                        <div class="input-actions">
                            <button class="send-button" id="send">Send</button>
                            <label for="fileInput" class="fancy-upload">Upload Image</label>
                            <input type="file" id="fileInput" accept="image/*" style="display: none;" />
                        </div>
                    </div>
                    <div id="uploadStatus"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="voip-container" id="voipContainer">
        <button class="voip-call-btn audio-call" id="voipToggleBtn" title="Voice/Video Call">
            ðŸ“ž
        </button>
        <div class="voip-panel" id="voipPanel">
            <div class="voip-panel-header">
                <h3>Start a Call</h3>
                <button class="voip-panel-close" id="voipPanelClose">Ã—</button>
            </div>
            <div class="voip-user-list" id="voipUserList">
                <div class="voip-no-users">No online users</div>
            </div>
        </div>
    </div>
    
    <div class="voip-overlay" id="voipOverlay"></div>
    
    <div class="voip-incoming-call" id="voipIncomingCall">
        <div class="voip-incoming-avatar" id="incomingAvatar">?</div>
        <div class="voip-incoming-name" id="incomingName">Unknown</div>
        <div class="voip-incoming-type" id="incomingType">Incoming call...</div>
        <div class="voip-incoming-actions">
            <button class="voip-btn-accept" id="acceptCallBtn" title="Accept">âœ“</button>
            <button class="voip-btn-reject" id="rejectCallBtn" title="Reject">âœ•</button>
        </div>
    </div>
    
    <div class="voip-active-call" id="voipActiveCall">
        <div class="voip-video-container" id="videoContainer">
            <video class="voip-remote-video" id="remoteVideo" autoplay playsinline></video>
            <video class="voip-local-video" id="localVideo" autoplay playsinline muted></video>
            <div class="voip-call-info">
                <h3 id="activeCallName">Unknown</h3>
                <div class="voip-call-duration" id="callDuration">00:00</div>
            </div>
        </div>
        <div class="voip-call-controls">
            <button class="voip-control-btn mute" id="muteBtn" title="Mute">ðŸŽ¤</button>
            <button class="voip-control-btn video-toggle" id="videoToggleBtn" title="Toggle Video">ðŸ“¹</button>
            <button class="voip-control-btn end-call" id="endCallBtn" title="End Call">ðŸ“ž</button>
        </div>
    </div>
    
    <script src="/static/voip.js"></script>
    <script>
        // Initialize WebSocket connection
        const ws = new WebSocket(`ws://${window.location.host}/ws`);
        let wsReady = false;
        
        // Get DOM elements
        const messagesDiv = document.getElementById('messages');
        const input = document.getElementById('input');
        const sendBtn = document.getElementById('send');
        const userListDiv = document.getElementById('userList');
        const usernameInput = document.getElementById('username');
        const fileInput = document.getElementById('fileInput');
        const uploadStatus = document.getElementById('uploadStatus');
        const historySearch = document.getElementById('historySearch');
        const historyFilter = document.getElementById('historyFilter');
        const loadHistoryBtn = document.getElementById('loadHistoryBtn');
        const historyList = document.getElementById('historyList');
        const historyLoading = document.getElementById('historyLoading');
        
        let currentUser = '';
        let historyOffset = 0;
        const historyPageSize = 50;
        let hasHistoryLoaded = false;
        let firstNewMessageSent = false;
        let notificationEnabled = false;

        function requestNotificationPermission() {
            if (!('Notification' in window)) {
                console.log('This browser does not support notifications');
                return;
            }
            
            if (Notification.permission === 'granted') {
                notificationEnabled = true;
                return;
            }
            
            if (Notification.permission !== 'denied') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        notificationEnabled = true;
                        console.log('Notification permission granted');
                    }
                });
            }
        }

        function showNotification(username, message) {
            if (!notificationEnabled || document.hasFocus()) {
                return;
            }
            
            const notification = new Notification(`${username}`, {
                body: message,
                icon: '/static/favicon.ico',
                tag: 'chatroom-message',
                requireInteraction: false
            });
            
            notification.onclick = function() {
                window.focus();
                notification.close();
            };
            
            setTimeout(() => {
                notification.close();
            }, 5000);
        }
        
        function scrollToBottom(element, smooth = true) {
            if (!element) return;
            if (smooth && 'scrollBehavior' in document.documentElement.style) {
                element.scrollTo({
                    top: element.scrollHeight,
                    behavior: 'smooth'
                });
            } else {
                element.scrollTop = element.scrollHeight;
            }
        }

        // localStorage functions
        function saveUsername(username) {
            localStorage.setItem('chatroom_username', username);
        }

        function loadUsername() {
            return localStorage.getItem('chatroom_username') || '';
        }

        // Format time as HH:mm:ss
        function formatTime(date = new Date()) {
            const h = String(date.getHours()).padStart(2, '0');
            const m = String(date.getMinutes()).padStart(2, '0');
            const s = String(date.getSeconds()).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        // WebSocket message handler
        ws.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'userlist') {
                    userListDiv.innerHTML = '';
                    data.users.forEach(u => {
                        const div = document.createElement('div');
                        div.className = 'user-item';
                        
                        const statusIndicator = document.createElement('div');
                        statusIndicator.className = 'user-status';
                        div.appendChild(statusIndicator);
                        
                        const usernameSpan = document.createElement('span');
                        usernameSpan.textContent = u;
                        div.appendChild(usernameSpan);
                        
                        userListDiv.appendChild(div);
                    });
                    if (typeof updateVOIPUserList === 'function') {
                        updateVOIPUserList(data.users);
                    }
                } else if (data.type === 'message') {
                    const msg = document.createElement('div');
                    msg.className = 'message-item';
                    
                    // Add "new messages" divider if this is the first new message after history
                    if (hasHistoryLoaded && !firstNewMessageSent) {
                        const newMessageDivider = document.createElement('div');
                        newMessageDivider.className = 'new-messages-divider';
                        newMessageDivider.innerHTML = '<span class="divider-text" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);">New Messages</span>';
                        newMessageDivider.style.opacity = '0';
                        newMessageDivider.style.transform = 'translateY(-10px)';
                        messagesDiv.appendChild(newMessageDivider);
                        
                        // Animate new message divider
                        setTimeout(() => {
                            newMessageDivider.style.transition = 'all 0.5s ease';
                            newMessageDivider.style.opacity = '1';
                            newMessageDivider.style.transform = 'translateY(0)';
                        }, 50);
                        
                        firstNewMessageSent = true;
                    }
                    
                    // Parse username and message
                    let username = '';
                    let messageText = '';
                    let isOwn = false;
                    
                    if (data.username) {
                        // New format: {username, text, timestamp}
                        username = data.username;
                        messageText = data.text;
                        isOwn = (username === currentUser);
                    } else {
                        // Legacy format: "username: message"
                        const match = data.text.match(/^([^:]+):\s([\s\S]*)$/);
                        if (match) {
                            username = match[1];
                            messageText = match[2];
                            isOwn = (username === currentUser);
                        } else {
                            messageText = data.text;
                        }
                    }
                    
                    if (isOwn) {
                        msg.className += ' own';
                    }
                    
                    // Create message structure
                    const msgMeta = document.createElement('div');
                    msgMeta.className = 'msg-meta';
                    
                    if (username) {
                        const msgUser = document.createElement('span');
                        msgUser.className = 'msg-user';
                        msgUser.textContent = username;
                        msgMeta.appendChild(msgUser);
                    }
                    
                    const msgTime = document.createElement('span');
                    msgTime.className = 'msg-time';
                    msgTime.textContent = data.timestamp || formatTime();
                    msgMeta.appendChild(msgTime);
                    
                    msg.appendChild(msgMeta);
                    
                    const msgContent = document.createElement('div');
                    msgContent.className = 'msg-text';
                    msgContent.textContent = messageText;
                    msg.appendChild(msgContent);
                    
                    messagesDiv.appendChild(msg);
                    scrollToBottom(messagesDiv, true);
                    
                    if (username && messageText && !isOwn) {
                        showNotification(username, messageText);
                    }
                } else if (data.type === 'error') {
                    alert(data.text);
                } else if (data.type === 'info') {
                    const info = document.createElement('div');
                    info.className = 'message-item info-item';
                    info.textContent = data.text;
                    messagesDiv.appendChild(info);
                    scrollToBottom(messagesDiv, true);
                }
            } catch (e) {
                console.error('Invalid message', event.data);
            }
        };

        // Send button click handler
        sendBtn.onclick = function() {
            const username = usernameInput.value.trim();
            const text = input.value.trim();
            
            // Check if WebSocket is ready
            if (!wsReady) {
                alert('Connection not ready. Please wait...');
                return;
            }
            
            // Check if username is empty
            if (!username) {
                alert('Please enter a username first');
                usernameInput.focus();
                return;
            }
            
            // Check if message is empty
            if (!text) {
                alert('Please enter a message');
                input.focus();
                return;
            }
            
            // If username changed, update it first
            if (currentUser !== username) {
                currentUser = username;
                saveUsername(username); // Save to localStorage
                ws.send(username);
            }
            
            // Send the message
            ws.send(text);
            input.value = '';
            input.focus();
        };

        // Textarea keydown handler - Ctrl+Enter to send, Enter for newline
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                // Ctrl+Enter or Cmd+Enter (for Mac) to add newline
                if (e.ctrlKey || e.metaKey) {
                    // Prevent default to avoid any unwanted behavior
                    e.preventDefault();
                    // Insert newline manually
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const value = this.value;
                    this.value = value.substring(0, start) + '\n' + value.substring(end);
                    // Restore cursor position
                    this.selectionStart = this.selectionEnd = start + 1;
                    return;
                }
                // Normal Enter to send message
                e.preventDefault();
                sendBtn.click();
            }
        });

        // Username input blur handler - update current user when username is changed
        usernameInput.addEventListener('blur', function() {
            const username = this.value.trim();
            if (username && currentUser !== username && wsReady) {
                currentUser = username;
                saveUsername(username); // Save to localStorage
                ws.send(username);
            }
        });

        // Username input keyup handler (Enter key to focus message input)
        usernameInput.addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                input.focus();
            }
        });

        // Handle file selection automatically
        fileInput.addEventListener('change', async function() {
            const file = fileInput.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            try {
                uploadStatus.textContent = 'Uploading...';
                const res = await fetch('/upload', { method: 'POST', body: formData });
                const data = await res.json();
                if (data.url) {
                    // Display the uploaded image in the chat
                    const imgContainer = document.createElement('div');
                    imgContainer.className = 'message-item';
                    
                    const img = document.createElement('img');
                    img.src = data.url;
                    img.style.maxWidth = '300px';
                    img.style.maxHeight = '300px';
                    img.style.margin = '8px 0';
                    
                    imgContainer.appendChild(img);
                    messagesDiv.appendChild(imgContainer);
                    scrollToBottom(messagesDiv, true);
                }
                uploadStatus.textContent = '';
                fileInput.value = ''; // Clear the file input
            } catch (error) {
                uploadStatus.textContent = 'Upload failed';
                console.error('Upload error:', error);
            }
        });

        // WebSocket connection ready handler
        ws.addEventListener('open', function() {
            wsReady = true;
            const savedUsername = loadUsername();
            if (savedUsername) {
                usernameInput.value = savedUsername;
                currentUser = savedUsername;
                ws.send(savedUsername);
                initVOIP();
            }
        });

        // Load history from API
        async function loadHistory() {
            try {
                historyLoading.style.display = 'block';
                const keyword = historySearch.value.trim();
                const username = historyFilter.value.trim();
                
                let url = `/api/history?limit=${historyPageSize}&offset=${historyOffset}`;
                if (username) url += `&username=${encodeURIComponent(username)}`;
                if (keyword) url += `&keyword=${encodeURIComponent(keyword)}`;
                
                const res = await fetch(url);
                const data = await res.json();
                
                if (data.success && data.messages) {
                    if (historyOffset === 0) {
                        historyList.innerHTML = '';
                    }
                    
                    data.messages.forEach(msg => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'history-message';
                        msgDiv.innerHTML = `<strong>${msg.username}</strong> <span class="time">${msg.timestamp}</span><br/><span class="content">${escapeHtml(msg.content)}</span>`;
                        historyList.appendChild(msgDiv);
                    });
                    
                    historyOffset += data.messages.length;
                    
                    if (data.messages.length < historyPageSize) {
                        // All loaded
                        const endMsg = document.createElement('div');
                        endMsg.className = 'history-end';
                        endMsg.textContent = '--- End of history ---';
                        historyList.appendChild(endMsg);
                    }
                }
                historyLoading.style.display = 'none';
            } catch (error) {
                console.error('Error loading history:', error);
                historyLoading.style.display = 'none';
            }
        }
        
        // Escape HTML for security
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Load history button handler
        loadHistoryBtn.addEventListener('click', function() {
            historyOffset = 0;
            loadHistory();
        });
        
        // Search and filter handlers
        historySearch.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                historyOffset = 0;
                loadHistory();
            }
        });
        
        historyFilter.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                historyOffset = 0;
                loadHistory();
            }
        });
        
        // Load more on scroll
        let historyContainer = document.querySelector('.history-container');
        historyContainer.addEventListener('scroll', function() {
            if (historyContainer.scrollTop + historyContainer.clientHeight >= historyContainer.scrollHeight - 10) {
                const endMsg = historyList.querySelector('.history-end');
                if (!endMsg) {
                    loadHistory();
                }
            }
        });
        
        // Load initial chat history on startup
        async function loadInitialHistory() {
            try {
                const res = await fetch('/api/history/initial?limit=20');
                const data = await res.json();
                
                if (data.success && data.messages.length > 0) {
                    // Add history messages in reverse order to show newest first at bottom
                    const reversedMessages = [...data.messages].reverse();
                    reversedMessages.forEach((msg, index) => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'message-item history-message-item';
                        msgDiv.style.opacity = '0';
                        msgDiv.style.transform = 'translateY(20px)';
                        
                        // Create message structure (same as live messages)
                        const msgMeta = document.createElement('div');
                        msgMeta.className = 'msg-meta';
                        
                        const msgUser = document.createElement('span');
                        msgUser.className = 'msg-user';
                        msgUser.textContent = msg.username;
                        msgMeta.appendChild(msgUser);
                        
                        const msgTime = document.createElement('span');
                        msgTime.className = 'msg-time';
                        msgTime.textContent = msg.timestamp;
                        msgMeta.appendChild(msgTime);
                        
                        msgDiv.appendChild(msgMeta);
                        
                        const msgContent = document.createElement('div');
                        msgContent.className = 'msg-text';
                        msgContent.textContent = msg.content;
                        msgDiv.appendChild(msgContent);
                        
                        messagesDiv.appendChild(msgDiv);
                        
                        // Staggered animation for each message
                        setTimeout(() => {
                            msgDiv.style.transition = 'all 0.3s ease';
                            msgDiv.style.opacity = '1';
                            msgDiv.style.transform = 'translateY(0)';
                        }, 150 + (index * 50));
                    });
                    
                    // Scroll to bottom after all animations complete
                    setTimeout(() => {
                        scrollToBottom(messagesDiv, true);
                        hasHistoryLoaded = true;
                    }, 150 + (reversedMessages.length * 50));
                } else {
                    hasHistoryLoaded = true;
                }
            } catch (error) {
                console.error('Error loading initial history:', error);
                hasHistoryLoaded = true;
            }
        }

        let voipClient = null;
        let incomingCallData = null;
        let callStartTime = null;
        let callDurationInterval = null;

        function initVOIP() {
            const voipWsUrl = `ws://${window.location.host}/ws/voip`;
            voipClient = new VOIPClient(voipWsUrl);
            
            voipClient.onCallRequest = (fromUser, callId, callType) => {
                incomingCallData = { fromUser, callId, callType };
                showIncomingCall(fromUser, callType);
            };
            
            voipClient.onCallAccepted = (fromUser) => {
                hideIncomingCall();
                showActiveCall(fromUser);
            };
            
            voipClient.onCallRejected = (fromUser) => {
                hideIncomingCall();
                alert(`${fromUser} rejected your call`);
            };
            
            voipClient.onCallEnded = (fromUser) => {
                hideActiveCall();
                hideIncomingCall();
            };
            
            voipClient.onRemoteStream = (stream) => {
                const remoteVideo = document.getElementById('remoteVideo');
                remoteVideo.srcObject = stream;
            };
            
            voipClient.onError = (error) => {
                console.error('VOIP Error:', error);
                alert(`Call error: ${error}`);
                hideActiveCall();
                hideIncomingCall();
            };
            
            voipClient.onCallBusy = (fromUser) => {
                alert(`${fromUser} is currently in another call`);
            };
            
            if (currentUser) {
                voipClient.connect(currentUser).catch(console.error);
            }
        }

        function showIncomingCall(fromUser, callType) {
            document.getElementById('incomingAvatar').textContent = fromUser.charAt(0).toUpperCase();
            document.getElementById('incomingName').textContent = fromUser;
            document.getElementById('incomingType').textContent = 
                callType === 'video' ? 'Incoming video call...' : 'Incoming audio call...';
            document.getElementById('voipIncomingCall').classList.add('active');
            document.getElementById('voipOverlay').classList.add('active');
        }

        function hideIncomingCall() {
            document.getElementById('voipIncomingCall').classList.remove('active');
            document.getElementById('voipOverlay').classList.remove('active');
            incomingCallData = null;
        }

        function showActiveCall(withUser) {
            document.getElementById('activeCallName').textContent = withUser;
            document.getElementById('voipActiveCall').classList.add('active');
            
            if (voipClient.localStream) {
                document.getElementById('localVideo').srcObject = voipClient.localStream;
            }
            
            const videoContainer = document.getElementById('videoContainer');
            if (voipClient.currentCallType === 'audio') {
                videoContainer.innerHTML = `
                    <div class="voip-audio-only-indicator">
                        <div class="voip-audio-only-avatar">${withUser.charAt(0).toUpperCase()}</div>
                        <h3>${withUser}</h3>
                    </div>
                `;
            }
            
            callStartTime = Date.now();
            callDurationInterval = setInterval(updateCallDuration, 1000);
        }

        function hideActiveCall() {
            document.getElementById('voipActiveCall').classList.remove('active');
            if (callDurationInterval) {
                clearInterval(callDurationInterval);
                callDurationInterval = null;
            }
            callStartTime = null;
            document.getElementById('callDuration').textContent = '00:00';
        }

        function updateCallDuration() {
            if (!callStartTime) return;
            const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('callDuration').textContent = `${minutes}:${seconds}`;
        }

        function updateVOIPUserList(users) {
            const voipUserList = document.getElementById('voipUserList');
            const filteredUsers = users.filter(u => u !== currentUser);
            
            if (filteredUsers.length === 0) {
                voipUserList.innerHTML = '<div class="voip-no-users">No online users</div>';
                return;
            }
            
            voipUserList.innerHTML = filteredUsers.map(user => `
                <div class="voip-user-item">
                    <div class="voip-user-info">
                        <div class="voip-user-avatar">${user.charAt(0).toUpperCase()}</div>
                        <span class="voip-user-name">${user}</span>
                    </div>
                    <div class="voip-call-actions">
                        <button class="audio-btn" onclick="startCall('${user}', 'audio')" title="Audio Call">ðŸ“ž</button>
                        <button class="video-btn" onclick="startCall('${user}', 'video')" title="Video Call">ðŸ“¹</button>
                    </div>
                </div>
            `).join('');
        }

        async function startCall(targetUser, callType) {
            if (!voipClient) {
                alert('VOIP not initialized');
                return;
            }
            
            try {
                await voipClient.startCall(targetUser, callType);
            } catch (error) {
                console.error('Failed to start call:', error);
                alert(`Failed to start call: ${error.message}`);
            }
        }

        document.getElementById('voipToggleBtn').addEventListener('click', function() {
            const panel = document.getElementById('voipPanel');
            panel.classList.toggle('active');
        });

        document.getElementById('voipPanelClose').addEventListener('click', function() {
            document.getElementById('voipPanel').classList.remove('active');
        });

        document.getElementById('acceptCallBtn').addEventListener('click', async function() {
            if (!incomingCallData || !voipClient) return;
            
            try {
                await voipClient.acceptCall(incomingCallData.callId, incomingCallData.callType);
                showActiveCall(incomingCallData.fromUser);
                hideIncomingCall();
            } catch (error) {
                console.error('Failed to accept call:', error);
                alert(`Failed to accept call: ${error.message}`);
            }
        });

        document.getElementById('rejectCallBtn').addEventListener('click', function() {
            if (!incomingCallData || !voipClient) return;
            voipClient.rejectCall(incomingCallData.callId);
            hideIncomingCall();
        });

        document.getElementById('endCallBtn').addEventListener('click', function() {
            if (voipClient) {
                voipClient.endCall();
            }
            hideActiveCall();
        });

        document.getElementById('muteBtn').addEventListener('click', function() {
            if (voipClient) {
                const isMuted = voipClient.toggleMute();
                this.classList.toggle('active', isMuted);
                this.textContent = isMuted ? 'ðŸ”‡' : 'ðŸŽ¤';
            }
        });

        document.getElementById('videoToggleBtn').addEventListener('click', function() {
            if (voipClient && voipClient.currentCallType === 'video') {
                const isOff = voipClient.toggleVideo();
                this.classList.toggle('active', isOff);
                this.textContent = isOff ? 'ðŸš«' : 'ðŸ“¹';
            }
        });

        window.addEventListener('load', function() {
            requestNotificationPermission();
            const savedUsername = loadUsername();
            if (savedUsername) {
                usernameInput.value = savedUsername;
                currentUser = savedUsername;
                if (wsReady) {
                    ws.send(savedUsername);
                }
            }
            loadInitialHistory();
        });
    </script>
</body>
</html>
