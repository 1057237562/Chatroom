<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI Chatroom</title>
    <link rel="stylesheet" href="/static/metro.css">
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="tile tile-primary" id="userListTile">
                <h3>Users</h3>
                <div class="user-list-container">
                    <div id="userList"></div>
                </div>
            </div>
            <div class="tile tile-secondary" id="historyTile">
                <h3>History</h3>
                <div class="history-controls">
                    <input type="text" id="historySearch" placeholder="Search messages..." />
                    <input type="text" id="historyFilter" placeholder="Filter by user..." />
                    <button class="btn-small" id="loadHistoryBtn">Load History</button>
                </div>
                <div class="history-container">
                    <div id="historyList"></div>
                    <div id="historyLoading" style="display:none; text-align:center; padding:10px;">
                        Loading...
                    </div>
                </div>
            </div>
        </div>
        <div class="main">
            <div class="chat-container">
                <div class="tile tile-primary" id="chatTile">
                    <div class="chat-header">
                        <h3>Chat</h3>
                    </div>
                    <div class="chat-messages" id="messages"></div>
                </div>
                <div id="inputArea">
                    <div class="textarea-wrapper">
                        <input type="text" id="username" placeholder="Enter Username" />
                        <textarea id="input" placeholder="Type a message... (Press Ctrl+Enter to send, Enter for new line)"></textarea>
                        <div class="input-actions">
                            <button class="send-button" id="send">Send</button>
                            <label for="fileInput" class="fancy-upload">Upload Image</label>
                            <input type="file" id="fileInput" accept="image/*" style="display: none;" />
                        </div>
                    </div>
                    <div id="uploadStatus"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Initialize WebSocket connection
        const ws = new WebSocket('ws://localhost:8000/ws');
        let wsReady = false;
        
        // Get DOM elements
        const messagesDiv = document.getElementById('messages');
        const input = document.getElementById('input');
        const sendBtn = document.getElementById('send');
        const userListDiv = document.getElementById('userList');
        const usernameInput = document.getElementById('username');
        const fileInput = document.getElementById('fileInput');
        const uploadStatus = document.getElementById('uploadStatus');
        const historySearch = document.getElementById('historySearch');
        const historyFilter = document.getElementById('historyFilter');
        const loadHistoryBtn = document.getElementById('loadHistoryBtn');
        const historyList = document.getElementById('historyList');
        const historyLoading = document.getElementById('historyLoading');
        
        let currentUser = '';
        let historyOffset = 0;
        const historyPageSize = 50;
        let hasHistoryLoaded = false;
        let firstNewMessageSent = false;
        
        function scrollToBottom(element, smooth = true) {
            if (!element) return;
            if (smooth && 'scrollBehavior' in document.documentElement.style) {
                element.scrollTo({
                    top: element.scrollHeight,
                    behavior: 'smooth'
                });
            } else {
                element.scrollTop = element.scrollHeight;
            }
        }

        // localStorage functions
        function saveUsername(username) {
            localStorage.setItem('chatroom_username', username);
        }

        function loadUsername() {
            return localStorage.getItem('chatroom_username') || '';
        }

        // Format time as HH:mm:ss
        function formatTime(date = new Date()) {
            const h = String(date.getHours()).padStart(2, '0');
            const m = String(date.getMinutes()).padStart(2, '0');
            const s = String(date.getSeconds()).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        // WebSocket message handler
        ws.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'userlist') {
                    userListDiv.innerHTML = '';
                    data.users.forEach(u => {
                        const div = document.createElement('div');
                        div.className = 'user-item';
                        
                        const statusIndicator = document.createElement('div');
                        statusIndicator.className = 'user-status';
                        div.appendChild(statusIndicator);
                        
                        const usernameSpan = document.createElement('span');
                        usernameSpan.textContent = u;
                        div.appendChild(usernameSpan);
                        
                        userListDiv.appendChild(div);
                    });
                } else if (data.type === 'message') {
                    const msg = document.createElement('div');
                    msg.className = 'message-item';
                    
                    // Add "new messages" divider if this is the first new message after history
                    if (hasHistoryLoaded && !firstNewMessageSent) {
                        const newMessageDivider = document.createElement('div');
                        newMessageDivider.className = 'history-divider';
                        newMessageDivider.innerHTML = '<span class="divider-text" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);">New Messages</span>';
                        newMessageDivider.style.opacity = '0';
                        newMessageDivider.style.transform = 'translateY(-10px)';
                        // Insert before the history divider
                        const historyDivider = messagesDiv.querySelector('.history-divider');
                        if (historyDivider) {
                            messagesDiv.insertBefore(newMessageDivider, historyDivider);
                        } else {
                            messagesDiv.appendChild(newMessageDivider);
                        }
                        
                        // Animate new message divider
                        setTimeout(() => {
                            newMessageDivider.style.transition = 'all 0.5s ease';
                            newMessageDivider.style.opacity = '1';
                            newMessageDivider.style.transform = 'translateY(0)';
                        }, 50);
                        
                        firstNewMessageSent = true;
                    }
                    
                    // Parse username and message
                    let username = '';
                    let messageText = '';
                    let isOwn = false;
                    
                    if (data.username) {
                        // New format: {username, text, timestamp}
                        username = data.username;
                        messageText = data.text;
                        isOwn = (username === currentUser);
                    } else {
                        // Legacy format: "username: message"
                        const match = data.text.match(/^([^:]+):\s([\s\S]*)$/);
                        if (match) {
                            username = match[1];
                            messageText = match[2];
                            isOwn = (username === currentUser);
                        } else {
                            messageText = data.text;
                        }
                    }
                    
                    if (isOwn) {
                        msg.className += ' own';
                    }
                    
                    // Create message structure
                    const msgMeta = document.createElement('div');
                    msgMeta.className = 'msg-meta';
                    
                    if (username) {
                        const msgUser = document.createElement('span');
                        msgUser.className = 'msg-user';
                        msgUser.textContent = username;
                        msgMeta.appendChild(msgUser);
                    }
                    
                    const msgTime = document.createElement('span');
                    msgTime.className = 'msg-time';
                    msgTime.textContent = data.timestamp || formatTime();
                    msgMeta.appendChild(msgTime);
                    
                    msg.appendChild(msgMeta);
                    
                    const msgContent = document.createElement('div');
                    msgContent.className = 'msg-text';
                    msgContent.textContent = messageText;
                    msg.appendChild(msgContent);
                    
                    // Insert new message before history divider if history is loaded
                    const historyDivider = messagesDiv.querySelector('.history-divider');
                    if (historyDivider && hasHistoryLoaded) {
                        messagesDiv.insertBefore(msg, historyDivider);
                    } else {
                        messagesDiv.appendChild(msg);
                    }
                    
                    scrollToBottom(messagesDiv, true);
                } else if (data.type === 'error') {
                    alert(data.text);
                } else if (data.type === 'info') {
                    const info = document.createElement('div');
                    info.className = 'message-item info-item';
                    info.textContent = data.text;
                    
                    // Insert info message before history divider if history is loaded
                    const historyDivider = messagesDiv.querySelector('.history-divider');
                    if (historyDivider && hasHistoryLoaded) {
                        messagesDiv.insertBefore(info, historyDivider);
                    } else {
                        messagesDiv.appendChild(info);
                    }
                    
                    scrollToBottom(messagesDiv, true);
                }
            } catch (e) {
                console.error('Invalid message', event.data);
            }
        };

        // Send button click handler
        sendBtn.onclick = function() {
            const username = usernameInput.value.trim();
            const text = input.value.trim();
            
            // Check if WebSocket is ready
            if (!wsReady) {
                alert('Connection not ready. Please wait...');
                return;
            }
            
            // Check if username is empty
            if (!username) {
                alert('Please enter a username first');
                usernameInput.focus();
                return;
            }
            
            // Check if message is empty
            if (!text) {
                alert('Please enter a message');
                input.focus();
                return;
            }
            
            // If username changed, update it first
            if (currentUser !== username) {
                currentUser = username;
                saveUsername(username); // Save to localStorage
                ws.send(username);
            }
            
            // Send the message
            ws.send(text);
            input.value = '';
            input.focus();
        };

        // Textarea keydown handler - Ctrl+Enter to send, Enter for newline
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                // Ctrl+Enter or Cmd+Enter (for Mac) to add newline
                if (e.ctrlKey || e.metaKey) {
                    // Prevent default to avoid any unwanted behavior
                    e.preventDefault();
                    // Insert newline manually
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const value = this.value;
                    this.value = value.substring(0, start) + '\n' + value.substring(end);
                    // Restore cursor position
                    this.selectionStart = this.selectionEnd = start + 1;
                    return;
                }
                // Normal Enter to send message
                e.preventDefault();
                sendBtn.click();
            }
        });

        // Username input blur handler - update current user when username is changed
        usernameInput.addEventListener('blur', function() {
            const username = this.value.trim();
            if (username && currentUser !== username && wsReady) {
                currentUser = username;
                saveUsername(username); // Save to localStorage
                ws.send(username);
            }
        });

        // Username input keyup handler (Enter key to focus message input)
        usernameInput.addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                input.focus();
            }
        });

        // Handle file selection automatically
        fileInput.addEventListener('change', async function() {
            const file = fileInput.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            try {
                uploadStatus.textContent = 'Uploading...';
                const res = await fetch('/upload', { method: 'POST', body: formData });
                const data = await res.json();
                if (data.url) {
                    // Display the uploaded image in the chat
                    const imgContainer = document.createElement('div');
                    imgContainer.className = 'message-item';
                    
                    const img = document.createElement('img');
                    img.src = data.url;
                    img.style.maxWidth = '300px';
                    img.style.maxHeight = '300px';
                    img.style.margin = '8px 0';
                    
                    imgContainer.appendChild(img);
                    messagesDiv.appendChild(imgContainer);
                    scrollToBottom(messagesDiv, true);
                }
                uploadStatus.textContent = '';
                fileInput.value = ''; // Clear the file input
            } catch (error) {
                uploadStatus.textContent = 'Upload failed';
                console.error('Upload error:', error);
            }
        });

        // WebSocket connection ready handler
        ws.addEventListener('open', function() {
            wsReady = true;
            const savedUsername = loadUsername();
            if (savedUsername) {
                usernameInput.value = savedUsername;
                currentUser = savedUsername;
                ws.send(savedUsername);
            }
        });

        // Load history from API
        async function loadHistory() {
            try {
                historyLoading.style.display = 'block';
                const keyword = historySearch.value.trim();
                const username = historyFilter.value.trim();
                
                let url = `/api/history?limit=${historyPageSize}&offset=${historyOffset}`;
                if (username) url += `&username=${encodeURIComponent(username)}`;
                if (keyword) url += `&keyword=${encodeURIComponent(keyword)}`;
                
                const res = await fetch(url);
                const data = await res.json();
                
                if (data.success && data.messages) {
                    if (historyOffset === 0) {
                        historyList.innerHTML = '';
                    }
                    
                    data.messages.forEach(msg => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'history-message';
                        msgDiv.innerHTML = `<strong>${msg.username}</strong> <span class="time">${msg.timestamp}</span><br/><span class="content">${escapeHtml(msg.content)}</span>`;
                        historyList.appendChild(msgDiv);
                    });
                    
                    historyOffset += data.messages.length;
                    
                    if (data.messages.length < historyPageSize) {
                        // All loaded
                        const endMsg = document.createElement('div');
                        endMsg.className = 'history-end';
                        endMsg.textContent = '--- End of history ---';
                        historyList.appendChild(endMsg);
                    }
                }
                historyLoading.style.display = 'none';
            } catch (error) {
                console.error('Error loading history:', error);
                historyLoading.style.display = 'none';
            }
        }
        
        // Escape HTML for security
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Load history button handler
        loadHistoryBtn.addEventListener('click', function() {
            historyOffset = 0;
            loadHistory();
        });
        
        // Search and filter handlers
        historySearch.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                historyOffset = 0;
                loadHistory();
            }
        });
        
        historyFilter.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                historyOffset = 0;
                loadHistory();
            }
        });
        
        // Load more on scroll
        let historyContainer = document.querySelector('.history-container');
        historyContainer.addEventListener('scroll', function() {
            if (historyContainer.scrollTop + historyContainer.clientHeight >= historyContainer.scrollHeight - 10) {
                const endMsg = historyList.querySelector('.history-end');
                if (!endMsg) {
                    loadHistory();
                }
            }
        });
        
        // Load initial chat history on startup
        async function loadInitialHistory() {
            try {
                const res = await fetch('/api/history/initial?limit=20');
                const data = await res.json();
                
                if (data.success && data.messages.length > 0) {
                    // Add history messages in reverse order to show newest first at bottom
                    const reversedMessages = [...data.messages].reverse();
                    reversedMessages.forEach((msg, index) => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'message-item history-message-item';
                        msgDiv.style.opacity = '0';
                        msgDiv.style.transform = 'translateY(20px)';
                        
                        // Create message structure (same as live messages)
                        const msgMeta = document.createElement('div');
                        msgMeta.className = 'msg-meta';
                        
                        const msgUser = document.createElement('span');
                        msgUser.className = 'msg-user';
                        msgUser.textContent = msg.username;
                        msgMeta.appendChild(msgUser);
                        
                        const msgTime = document.createElement('span');
                        msgTime.className = 'msg-time';
                        msgTime.textContent = msg.timestamp;
                        msgMeta.appendChild(msgTime);
                        
                        msgDiv.appendChild(msgMeta);
                        
                        const msgContent = document.createElement('div');
                        msgContent.className = 'msg-text';
                        msgContent.textContent = msg.content;
                        msgDiv.appendChild(msgContent);
                        
                        messagesDiv.appendChild(msgDiv);
                        
                        // Staggered animation for each message
                        setTimeout(() => {
                            msgDiv.style.transition = 'all 0.3s ease';
                            msgDiv.style.opacity = '1';
                            msgDiv.style.transform = 'translateY(0)';
                        }, 150 + (index * 50));
                    });
                    
                    // Add history divider at the bottom after all messages
                    setTimeout(() => {
                        const historyDivider = document.createElement('div');
                        historyDivider.className = 'history-divider';
                        historyDivider.innerHTML = '<span class="divider-text">History Above</span>';
                        historyDivider.style.opacity = '0';
                        historyDivider.style.transform = 'translateY(-10px)';
                        messagesDiv.appendChild(historyDivider);
                        
                        // Animate divider appearance
                        setTimeout(() => {
                            historyDivider.style.transition = 'all 0.5s ease';
                            historyDivider.style.opacity = '1';
                            historyDivider.style.transform = 'translateY(0)';
                        }, 100);
                        
                        // Scroll to bottom after all animations complete
                        setTimeout(() => {
                            scrollToBottom(messagesDiv, true);
                            hasHistoryLoaded = true;
                        }, 500);
                    }, 150 + (reversedMessages.length * 50));
                } else {
                    hasHistoryLoaded = true;
                }
            } catch (error) {
                console.error('Error loading initial history:', error);
                hasHistoryLoaded = true;
            }
        }

        // Initialize page
        window.addEventListener('load', function() {
            const savedUsername = loadUsername();
            if (savedUsername) {
                usernameInput.value = savedUsername;
                currentUser = savedUsername;
                // If WebSocket is already ready, send username immediately
                if (wsReady) {
                    ws.send(savedUsername);
                }
            }
            // Load initial chat history (instead of sidebar history)
            loadInitialHistory();
        });
    </script>
</body>
</html>
