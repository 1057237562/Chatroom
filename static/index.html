<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI Chatroom</title>
    <link rel="stylesheet" href="/static/metro.css">
    <link rel="stylesheet" href="/static/voice_chat.css">
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="tile tile-primary" id="userListTile">
                <h3>Users</h3>
                <div class="user-list-container">
                    <div id="userList"></div>
                </div>
            </div>
            <div class="tile tile-secondary" id="historyTile">
                <h3>History</h3>
                <div class="history-controls">
                    <input type="text" id="historySearch" placeholder="Search messages..." />
                    <input type="text" id="historyFilter" placeholder="Filter by user..." />
                    <button class="btn-small" id="loadHistoryBtn">Load History</button>
                </div>
                <div class="history-container">
                    <div id="historyList"></div>
                    <div id="historyLoading" style="display:none; text-align:center; padding:10px;">
                        Loading...
                    </div>
                </div>
            </div>
        </div>
        <div class="main">
            <div class="chat-container">
                <div class="tile tile-primary" id="chatTile">
                    <div class="chat-header">
                        <h3>Chat</h3>
                    </div>
                    <div class="chat-messages" id="messages"></div>
                </div>
                <div class="tile tile-secondary" id="inputArea">
                    <div class="textarea-wrapper">
                        <input type="text" id="username" placeholder="Enter Username" />
                        <textarea id="input" placeholder="Type a message... (Press Ctrl+Enter to send, Enter for new line)"></textarea>
                        <div class="input-actions">
                            <button class="send-button" id="send">Send</button>
                            <label for="fileInput" class="fancy-upload">Upload Image</label>
                            <input type="file" id="fileInput" accept="image/*" style="display: none;" />
                        </div>
                    </div>
                    <div id="uploadStatus"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="voice-chat-container" id="voiceChatContainer">
        <button class="voice-toggle-btn" id="voiceToggleBtn" title="Voice Chat">
            üé§
        </button>
        <div class="voice-panel" id="voicePanel">
            <div class="voice-panel-header">
                <h3>Voice Chat</h3>
                <button class="voice-panel-close" id="voicePanelClose">√ó</button>
            </div>
            <div class="voice-status" id="voiceStatus">
                <span class="status-text">Click to join voice chat</span>
            </div>
            <div class="voice-participants" id="voiceParticipants">
                <div class="voice-no-users">Not connected</div>
            </div>
            <div class="voice-controls">
                <button class="voice-btn" id="joinVoiceBtn" title="Join Voice">Join</button>
                <button class="voice-btn mute-btn" id="voiceMuteBtn" title="Mute" style="display:none;">üé§</button>
                <button class="voice-btn screen-btn" id="screenShareBtn" title="Share Screen" style="display:none;">üì∫</button>
                <button class="voice-btn leave-btn" id="leaveVoiceBtn" title="Leave" style="display:none;">Leave</button>
            </div>
        </div>
    </div>
    
    <div class="screen-share-container" id="screenShareContainer" style="display: none;">
        <div class="screen-share-resize-handle nw" data-resize="nw"></div>
        <div class="screen-share-resize-handle ne" data-resize="ne"></div>
        <div class="screen-share-resize-handle sw" data-resize="sw"></div>
        <div class="screen-share-resize-handle se" data-resize="se"></div>
        <div class="screen-share-header">
            <span class="screen-share-title" id="screenShareTitle">Screen Share</span>
            <button class="screen-share-close" id="screenShareClose">√ó</button>
        </div>
        <div class="screen-share-content">
            <img id="screenShareImage" alt="Screen Share" />
            <div class="screen-share-overlay" id="screenShareOverlay">
                <div class="screen-share-loading">Loading...</div>
            </div>
        </div>
    </div>
    
    <script src="/static/voice_chat.js"></script>
    <script>
        // Initialize WebSocket connection (auto-detect ws/wss based on protocol)
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
        let wsReady = false;
        
        // Get DOM elements
        const messagesDiv = document.getElementById('messages');
        const input = document.getElementById('input');
        const sendBtn = document.getElementById('send');
        const userListDiv = document.getElementById('userList');
        const usernameInput = document.getElementById('username');
        const fileInput = document.getElementById('fileInput');
        const uploadStatus = document.getElementById('uploadStatus');
        const historySearch = document.getElementById('historySearch');
        const historyFilter = document.getElementById('historyFilter');
        const loadHistoryBtn = document.getElementById('loadHistoryBtn');
        const historyList = document.getElementById('historyList');
        const historyLoading = document.getElementById('historyLoading');
        
        let currentUser = '';
        let historyOffset = 0;
        const historyPageSize = 50;
        let hasHistoryLoaded = false;
        let firstNewMessageSent = false;
        let notificationEnabled = false;
        let audioContext = null;

        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            return audioContext;
        }

        function playNotificationSound() {
            const ctx = initAudioContext();
            if (!ctx) return;
            
            try {
                if (ctx.state === 'suspended') {
                    ctx.resume();
                }
                
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                
                oscillator.frequency.setValueAtTime(800, ctx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                
                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + 0.3);
            } catch (e) {
                console.log('Failed to play notification sound:', e);
            }
        }

        function requestNotificationPermission() {
            if (!('Notification' in window)) {
                console.log('This browser does not support notifications');
                showNotificationStatus('unsupported');
                return;
            }
            
            if (Notification.permission === 'granted') {
                notificationEnabled = true;
                showNotificationStatus('granted');
                return;
            }
            
            if (Notification.permission === 'denied') {
                showNotificationStatus('denied');
                return;
            }
            
            showNotificationStatus('default');
            
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    notificationEnabled = true;
                    showNotificationStatus('granted');
                    console.log('Notification permission granted');
                    
                    initAudioContext();
                } else if (permission === 'denied') {
                    showNotificationStatus('denied');
                } else {
                    showNotificationStatus('default');
                }
            });
        }

        function showNotificationStatus(status) {
            let statusDiv = document.getElementById('notification-status');
            if (!statusDiv) {
                statusDiv = document.createElement('div');
                statusDiv.id = 'notification-status';
                statusDiv.style.cssText = 'position: fixed; top: 10px; right: 10px; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 1000; transition: opacity 0.3s;';
                document.body.appendChild(statusDiv);
            }
            
            switch (status) {
                case 'granted':
                    statusDiv.textContent = 'üîî ÈÄöÁü•Â∑≤ÂêØÁî®';
                    statusDiv.style.background = '#4CAF50';
                    statusDiv.style.color = 'white';
                    break;
                case 'denied':
                    statusDiv.textContent = 'üîï ÈÄöÁü•Â∑≤Á¶ÅÁî®';
                    statusDiv.style.background = '#f44336';
                    statusDiv.style.color = 'white';
                    break;
                case 'unsupported':
                    statusDiv.textContent = '‚ö†Ô∏è ÊµèËßàÂô®‰∏çÊîØÊåÅÈÄöÁü•';
                    statusDiv.style.background = '#ff9800';
                    statusDiv.style.color = 'white';
                    break;
                case 'default':
                    statusDiv.innerHTML = 'üîî <a href="#" onclick="requestNotificationPermission(); return false;" style="color: white; text-decoration: underline;">ÁÇπÂáªÂêØÁî®ÈÄöÁü•</a>';
                    statusDiv.style.background = '#2196F3';
                    statusDiv.style.color = 'white';
                    break;
            }
            
            setTimeout(() => {
                statusDiv.style.opacity = '0';
                setTimeout(() => {
                    if (statusDiv.parentNode) {
                        statusDiv.parentNode.removeChild(statusDiv);
                    }
                }, 300);
            }, 5000);
        }

        function showNotification(username, message) {
            if (!notificationEnabled) {
                return;
            }
            
            playNotificationSound();
            
            if (document.hasFocus()) {
                return;
            }
            
            const notification = new Notification(`üí¨ ${username}`, {
                body: message,
                icon: '/static/favicon.ico',
                tag: 'chatroom-message',
                requireInteraction: false,
                silent: true,
                renotify: true
            });
            
            notification.onclick = function() {
                window.focus();
                notification.close();
            };
            
            setTimeout(() => {
                notification.close();
            }, 5000);
        }
        
        function scrollToBottom(element, smooth = true) {
            if (!element) return;
            if (smooth && 'scrollBehavior' in document.documentElement.style) {
                element.scrollTo({
                    top: element.scrollHeight,
                    behavior: 'smooth'
                });
            } else {
                element.scrollTop = element.scrollHeight;
            }
        }

        // localStorage functions
        function saveUsername(username) {
            localStorage.setItem('chatroom_username', username);
        }

        function loadUsername() {
            return localStorage.getItem('chatroom_username') || '';
        }

        // Format time as HH:mm:ss
        function formatTime(date = new Date()) {
            const h = String(date.getHours()).padStart(2, '0');
            const m = String(date.getMinutes()).padStart(2, '0');
            const s = String(date.getSeconds()).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        // WebSocket message handler
        ws.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'userlist') {
                    userListDiv.innerHTML = '';
                    data.users.forEach(u => {
                        const div = document.createElement('div');
                        div.className = 'user-item';
                        
                        const statusIndicator = document.createElement('div');
                        statusIndicator.className = 'user-status';
                        div.appendChild(statusIndicator);
                        
                        const usernameSpan = document.createElement('span');
                        usernameSpan.textContent = u;
                        div.appendChild(usernameSpan);
                        
                        userListDiv.appendChild(div);
                    });
                } else if (data.type === 'message') {
                    const msg = document.createElement('div');
                    msg.className = 'message-item';
                    
                    // Add "new messages" divider if this is the first new message after history
                    if (hasHistoryLoaded && !firstNewMessageSent) {
                        const newMessageDivider = document.createElement('div');
                        newMessageDivider.className = 'new-messages-divider';
                        newMessageDivider.innerHTML = '<span class="divider-text" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);">New Messages</span>';
                        newMessageDivider.style.opacity = '0';
                        newMessageDivider.style.transform = 'translateY(-10px)';
                        messagesDiv.appendChild(newMessageDivider);
                        
                        // Animate new message divider
                        setTimeout(() => {
                            newMessageDivider.style.transition = 'all 0.5s ease';
                            newMessageDivider.style.opacity = '1';
                            newMessageDivider.style.transform = 'translateY(0)';
                        }, 50);
                        
                        firstNewMessageSent = true;
                    }
                    
                    // Parse username and message
                    let username = '';
                    let messageText = '';
                    let isOwn = false;
                    
                    if (data.username) {
                        // New format: {username, text, timestamp}
                        username = data.username;
                        messageText = data.text;
                        isOwn = (username === currentUser);
                    } else {
                        // Legacy format: "username: message"
                        const match = data.text.match(/^([^:]+):\s([\s\S]*)$/);
                        if (match) {
                            username = match[1];
                            messageText = match[2];
                            isOwn = (username === currentUser);
                        } else {
                            messageText = data.text;
                        }
                    }
                    
                    if (isOwn) {
                        msg.className += ' own';
                    }
                    
                    // Create message structure
                    const msgMeta = document.createElement('div');
                    msgMeta.className = 'msg-meta';
                    
                    if (username) {
                        const msgUser = document.createElement('span');
                        msgUser.className = 'msg-user';
                        msgUser.textContent = username;
                        msgMeta.appendChild(msgUser);
                    }
                    
                    const msgTime = document.createElement('span');
                    msgTime.className = 'msg-time';
                    msgTime.textContent = data.timestamp || formatTime();
                    msgMeta.appendChild(msgTime);
                    
                    msg.appendChild(msgMeta);
                    
                    const msgContent = document.createElement('div');
                    msgContent.className = 'msg-text';
                    msgContent.textContent = messageText;
                    msg.appendChild(msgContent);
                    
                    messagesDiv.appendChild(msg);
                    scrollToBottom(messagesDiv, true);
                    
                    if (username && messageText && !isOwn) {
                        showNotification(username, messageText);
                    }
                } else if (data.type === 'error') {
                    alert(data.text);
                } else if (data.type === 'info') {
                    const info = document.createElement('div');
                    info.className = 'message-item info-item';
                    info.textContent = data.text;
                    messagesDiv.appendChild(info);
                    scrollToBottom(messagesDiv, true);
                } else if (data.type === 'private') {
                    const msg = document.createElement('div');
                    msg.className = 'message-item private-item';
                    
                    const msgMeta = document.createElement('div');
                    msgMeta.className = 'msg-meta';
                    
                    const msgUser = document.createElement('span');
                    msgUser.className = 'msg-user';
                    msgUser.textContent = `[Private from ${data.from}]`;
                    msgMeta.appendChild(msgUser);
                    
                    const msgTime = document.createElement('span');
                    msgTime.className = 'msg-time';
                    msgTime.textContent = formatTime();
                    msgMeta.appendChild(msgTime);
                    
                    msg.appendChild(msgMeta);
                    
                    const msgContent = document.createElement('div');
                    msgContent.className = 'msg-text';
                    msgContent.textContent = data.text;
                    msg.appendChild(msgContent);
                    
                    messagesDiv.appendChild(msg);
                    scrollToBottom(messagesDiv, true);
                    
                    showNotification(`[Private] ${data.from}`, data.text);
                }
            } catch (e) {
                console.error('Invalid message', event.data);
            }
        };

        // Send button click handler
        sendBtn.onclick = function() {
            const username = usernameInput.value.trim();
            const text = input.value.trim();
            
            // Check if WebSocket is ready
            if (!wsReady) {
                alert('Connection not ready. Please wait...');
                return;
            }
            
            // Check if username is empty
            if (!username) {
                alert('Please enter a username first');
                usernameInput.focus();
                return;
            }
            
            // Check if message is empty
            if (!text) {
                alert('Please enter a message');
                input.focus();
                return;
            }
            
            // If username changed, update it first
            if (currentUser !== username) {
                currentUser = username;
                saveUsername(username); // Save to localStorage
                ws.send(username);
            }
            
            // Send the message
            ws.send(text);
            input.value = '';
            input.focus();
        };

        // Textarea keydown handler - Ctrl+Enter to send, Enter for newline
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                // Ctrl+Enter or Cmd+Enter (for Mac) to add newline
                if (e.ctrlKey || e.metaKey) {
                    // Prevent default to avoid any unwanted behavior
                    e.preventDefault();
                    // Insert newline manually
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const value = this.value;
                    this.value = value.substring(0, start) + '\n' + value.substring(end);
                    // Restore cursor position
                    this.selectionStart = this.selectionEnd = start + 1;
                    return;
                }
                // Normal Enter to send message
                e.preventDefault();
                sendBtn.click();
            }
        });

        // Username input blur handler - update current user when username is changed
        usernameInput.addEventListener('blur', function() {
            const username = this.value.trim();
            if (username && currentUser !== username && wsReady) {
                currentUser = username;
                saveUsername(username);
                ws.send(username);
            }
        });

        // Username input keyup handler (Enter key to focus message input)
        usernameInput.addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                input.focus();
            }
        });

        // Handle file selection automatically
        fileInput.addEventListener('change', async function() {
            const file = fileInput.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            try {
                uploadStatus.textContent = 'Uploading...';
                const res = await fetch('/upload', { method: 'POST', body: formData });
                const data = await res.json();
                if (data.url) {
                    // Display the uploaded image in the chat
                    const imgContainer = document.createElement('div');
                    imgContainer.className = 'message-item';
                    
                    const img = document.createElement('img');
                    img.src = data.url;
                    img.style.maxWidth = '300px';
                    img.style.maxHeight = '300px';
                    img.style.margin = '8px 0';
                    
                    imgContainer.appendChild(img);
                    messagesDiv.appendChild(imgContainer);
                    scrollToBottom(messagesDiv, true);
                }
                uploadStatus.textContent = '';
                fileInput.value = ''; // Clear the file input
            } catch (error) {
                uploadStatus.textContent = 'Upload failed';
                console.error('Upload error:', error);
            }
        });

        // WebSocket connection ready handler
        ws.addEventListener('open', function() {
            wsReady = true;
            const savedUsername = loadUsername();
            if (savedUsername) {
                usernameInput.value = savedUsername;
                currentUser = savedUsername;
                ws.send(savedUsername);
            }
            initVOIP();
        });

        // Load history from API
        async function loadHistory() {
            try {
                historyLoading.style.display = 'block';
                const keyword = historySearch.value.trim();
                const username = historyFilter.value.trim();
                
                let url = `/api/history?limit=${historyPageSize}&offset=${historyOffset}`;
                if (username) url += `&username=${encodeURIComponent(username)}`;
                if (keyword) url += `&keyword=${encodeURIComponent(keyword)}`;
                
                const res = await fetch(url);
                const data = await res.json();
                
                if (data.success && data.messages) {
                    if (historyOffset === 0) {
                        historyList.innerHTML = '';
                    }
                    
                    data.messages.forEach(msg => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'history-message';
                        msgDiv.innerHTML = `<strong>${msg.username}</strong> <span class="time">${msg.timestamp}</span><br/><span class="content">${escapeHtml(msg.content)}</span>`;
                        historyList.appendChild(msgDiv);
                    });
                    
                    historyOffset += data.messages.length;
                    
                    if (data.messages.length < historyPageSize) {
                        // All loaded
                        const endMsg = document.createElement('div');
                        endMsg.className = 'history-end';
                        endMsg.textContent = '--- End of history ---';
                        historyList.appendChild(endMsg);
                    }
                }
                historyLoading.style.display = 'none';
            } catch (error) {
                console.error('Error loading history:', error);
                historyLoading.style.display = 'none';
            }
        }
        
        // Escape HTML for security
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Load history button handler
        loadHistoryBtn.addEventListener('click', function() {
            historyOffset = 0;
            loadHistory();
        });
        
        // Search and filter handlers
        historySearch.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                historyOffset = 0;
                loadHistory();
            }
        });
        
        historyFilter.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                historyOffset = 0;
                loadHistory();
            }
        });
        
        // Load more on scroll
        let historyContainer = document.querySelector('.history-container');
        historyContainer.addEventListener('scroll', function() {
            if (historyContainer.scrollTop + historyContainer.clientHeight >= historyContainer.scrollHeight - 10) {
                const endMsg = historyList.querySelector('.history-end');
                if (!endMsg) {
                    loadHistory();
                }
            }
        });
        
        // Load initial chat history on startup
        async function loadInitialHistory() {
            try {
                const res = await fetch('/api/history/initial?limit=20');
                const data = await res.json();
                
                if (data.success && data.messages.length > 0) {
                    // Add history messages in reverse order to show newest first at bottom
                    const reversedMessages = [...data.messages].reverse();
                    reversedMessages.forEach((msg, index) => {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'message-item history-message-item';
                        msgDiv.style.opacity = '0';
                        msgDiv.style.transform = 'translateY(20px)';
                        
                        // Create message structure (same as live messages)
                        const msgMeta = document.createElement('div');
                        msgMeta.className = 'msg-meta';
                        
                        const msgUser = document.createElement('span');
                        msgUser.className = 'msg-user';
                        msgUser.textContent = msg.username;
                        msgMeta.appendChild(msgUser);
                        
                        const msgTime = document.createElement('span');
                        msgTime.className = 'msg-time';
                        msgTime.textContent = msg.timestamp;
                        msgMeta.appendChild(msgTime);
                        
                        msgDiv.appendChild(msgMeta);
                        
                        const msgContent = document.createElement('div');
                        msgContent.className = 'msg-text';
                        msgContent.textContent = msg.content;
                        msgDiv.appendChild(msgContent);
                        
                        messagesDiv.appendChild(msgDiv);
                        
                        // Staggered animation for each message
                        setTimeout(() => {
                            msgDiv.style.transition = 'all 0.3s ease';
                            msgDiv.style.opacity = '1';
                            msgDiv.style.transform = 'translateY(0)';
                        }, 150 + (index * 50));
                    });
                    
                    // Scroll to bottom after all animations complete
                    setTimeout(() => {
                        scrollToBottom(messagesDiv, true);
                        hasHistoryLoaded = true;
                    }, 150 + (reversedMessages.length * 50));
                } else {
                    hasHistoryLoaded = true;
                }
            } catch (error) {
                console.error('Error loading initial history:', error);
                hasHistoryLoaded = true;
            }
        }

        let voiceClient = null;

        function initVoiceChat() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const voiceWsUrl = `${wsProtocol}//${window.location.host}/ws/voice`;
            voiceClient = new VoiceChatClient(voiceWsUrl);
            
            voiceClient.onUserListUpdate = (users, screenSharer, screenActive) => {
                updateVoiceParticipants(users, screenSharer);
                updateScreenShareState(screenSharer, screenActive);
            };
            
            voiceClient.onConnected = (roomId) => {
                updateVoiceStatus('connected', `Connected to ${roomId}`);
                showVoiceControls(true);
            };
            
            voiceClient.onDisconnected = () => {
                updateVoiceStatus('disconnected', 'Disconnected');
                showVoiceControls(false);
                hideScreenShare();
            };
            
            voiceClient.onError = (error) => {
                console.error('Voice chat error:', error);
                updateVoiceStatus('error', `Error: ${error}`);
            };
            
            voiceClient.onUserJoined = (username) => {
                updateVoiceStatus('connected', `${username} joined`);
            };
            
            voiceClient.onUserLeft = (username) => {
                updateVoiceStatus('connected', `${username} left`);
            };
            
            voiceClient.onScreenStateChange = (sharer, active) => {
                updateScreenShareState(sharer, active);
            };
            
            voiceClient.onScreenFrame = (fromUser, frameData) => {
                console.log('Received screen frame from:', fromUser, 'data length:', frameData ? frameData.length : 0);
                displayScreenFrame(fromUser, frameData);
            };
        }

        function updateVoiceStatus(status, message) {
            const statusEl = document.getElementById('voiceStatus');
            const statusText = statusEl.querySelector('.status-text');
            statusText.textContent = message;
            statusEl.className = `voice-status ${status}`;
        }

        function updateVoiceParticipants(users, screenSharer) {
            const participantsEl = document.getElementById('voiceParticipants');
            
            if (!users || users.length === 0) {
                participantsEl.innerHTML = '<div class="voice-no-users">No participants</div>';
                return;
            }
            
            participantsEl.innerHTML = users.map(user => {
                const isSharing = user === screenSharer;
                const sharingClass = isSharing ? 'sharing' : '';
                const sharingIndicator = isSharing ? '<span class="sharing-indicator">üì∫</span>' : '';
                return `
                <div class="voice-participant ${sharingClass} ${user === currentUser ? 'self' : ''}">
                    <div class="participant-avatar">${user.charAt(0).toUpperCase()}</div>
                    <span class="participant-name">${user}${user === currentUser ? ' (You)' : ''}${sharingIndicator}</span>
                </div>
            `}).join('');
        }

        function showVoiceControls(connected) {
            document.getElementById('joinVoiceBtn').style.display = connected ? 'none' : 'inline-block';
            document.getElementById('voiceMuteBtn').style.display = connected ? 'inline-block' : 'none';
            document.getElementById('screenShareBtn').style.display = connected ? 'inline-block' : 'none';
            document.getElementById('leaveVoiceBtn').style.display = connected ? 'inline-block' : 'none';
        }

        async function joinVoiceChat() {
            if (!currentUser) {
                alert('Please enter your username first');
                return;
            }
            
            if (!voiceClient) {
                initVoiceChat();
            }
            
            try {
                updateVoiceStatus('connecting', 'Connecting...');
                await voiceClient.connect(currentUser, 'default');
            } catch (error) {
                console.error('Failed to join voice chat:', error);
                updateVoiceStatus('error', `Failed to connect: ${error.message}`);
            }
        }

        function leaveVoiceChat() {
            if (voiceClient) {
                voiceClient.disconnect();
                showVoiceControls(false);
                updateVoiceParticipants([]);
                updateVoiceStatus('disconnected', 'Click to join voice chat');
            }
        }

        function toggleVoiceMute() {
            if (voiceClient) {
                const muted = voiceClient.toggleMute();
                const muteBtn = document.getElementById('voiceMuteBtn');
                muteBtn.textContent = muted ? 'üîá' : 'üé§';
                muteBtn.classList.toggle('muted', muted);
            }
        }

        function updateScreenShareState(sharer, active) {
            const screenBtn = document.getElementById('screenShareBtn');
            
            if (sharer && sharer !== currentUser) {
                screenBtn.style.display = 'none';
                screenBtn.classList.remove('active');
            } else if (voiceClient && voiceClient.isConnected) {
                screenBtn.style.display = 'inline-block';
                if (active && sharer === currentUser) {
                    screenBtn.classList.add('active');
                } else {
                    screenBtn.classList.remove('active');
                }
            }
            
            if (active && sharer) {
                showScreenShareContainer(sharer);
            } else {
                hideScreenShare();
            }
        }

        function showScreenShareContainer(sharer) {
            const container = document.getElementById('screenShareContainer');
            const title = document.getElementById('screenShareTitle');
            title.textContent = `${sharer}'s Screen`;
            container.style.display = 'flex';
        }

        function hideScreenShare() {
            const container = document.getElementById('screenShareContainer');
            container.style.display = 'none';
            const overlay = document.getElementById('screenShareOverlay');
            overlay.classList.remove('hidden');
        }

        function displayScreenFrame(fromUser, frameData) {
            const img = document.getElementById('screenShareImage');
            const overlay = document.getElementById('screenShareOverlay');
            
            img.src = frameData;
            overlay.classList.add('hidden');
            
            showScreenShareContainer(fromUser);
        }

        async function toggleScreenShare() {
            if (!voiceClient || !voiceClient.isConnected) {
                return;
            }
            
            const screenBtn = document.getElementById('screenShareBtn');
            
            if (voiceClient.isCurrentlyScreenSharing()) {
                voiceClient.stopScreenShare();
                screenBtn.classList.remove('active');
            } else {
                const success = await voiceClient.startScreenShare();
                if (success) {
                    screenBtn.classList.add('active');
                }
            }
        }

        document.getElementById('voiceToggleBtn').addEventListener('click', function() {
            const panel = document.getElementById('voicePanel');
            panel.classList.toggle('active');
        });

        document.getElementById('voicePanelClose').addEventListener('click', function() {
            document.getElementById('voicePanel').classList.remove('active');
        });

        document.getElementById('joinVoiceBtn').addEventListener('click', joinVoiceChat);
        document.getElementById('leaveVoiceBtn').addEventListener('click', leaveVoiceChat);
        document.getElementById('voiceMuteBtn').addEventListener('click', toggleVoiceMute);
        document.getElementById('screenShareBtn').addEventListener('click', toggleScreenShare);
        
        document.getElementById('screenShareClose').addEventListener('click', function() {
            const container = document.getElementById('screenShareContainer');
            container.style.display = 'none';
        });
        
        (function initScreenShareDrag() {
            const container = document.getElementById('screenShareContainer');
            const header = container.querySelector('.screen-share-header');
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            header.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('screen-share-close')) {
                    return;
                }
                isDragging = true;
                container.classList.add('dragging');
                
                const rect = container.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                initialX = rect.left;
                initialY = rect.top;
                
                container.style.transform = 'none';
                container.style.left = initialX + 'px';
                container.style.top = initialY + 'px';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                let newX = initialX + deltaX;
                let newY = initialY + deltaY;
                
                const maxX = window.innerWidth - container.offsetWidth;
                const maxY = window.innerHeight - container.offsetHeight;
                
                newX = Math.max(0, Math.min(newX, maxX));
                newY = Math.max(0, Math.min(newY, maxY));
                
                container.style.left = newX + 'px';
                container.style.top = newY + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    container.classList.remove('dragging');
                }
            });
        })();
        
        (function initScreenShareResize() {
            const container = document.getElementById('screenShareContainer');
            const handles = container.querySelectorAll('.screen-share-resize-handle');
            let isResizing = false;
            let currentHandle = null;
            let startX, startY, startWidth, startHeight, startLeft, startTop;
            const minWidth = 320;
            const minHeight = 200;
            
            handles.forEach(handle => {
                handle.addEventListener('mousedown', function(e) {
                    isResizing = true;
                    currentHandle = this.dataset.resize;
                    
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = container.offsetWidth;
                    startHeight = container.offsetHeight;
                    startLeft = container.offsetLeft;
                    startTop = container.offsetTop;
                    
                    e.preventDefault();
                    e.stopPropagation();
                });
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                let newWidth = startWidth;
                let newHeight = startHeight;
                let newLeft = startLeft;
                let newTop = startTop;
                
                switch (currentHandle) {
                    case 'se':
                        newWidth = Math.max(minWidth, startWidth + deltaX);
                        newHeight = Math.max(minHeight, startHeight + deltaY);
                        break;
                    case 'sw':
                        newWidth = Math.max(minWidth, startWidth - deltaX);
                        newHeight = Math.max(minHeight, startHeight + deltaY);
                        newLeft = startLeft + (startWidth - newWidth);
                        break;
                    case 'ne':
                        newWidth = Math.max(minWidth, startWidth + deltaX);
                        newHeight = Math.max(minHeight, startHeight - deltaY);
                        newTop = startTop + (startHeight - newHeight);
                        break;
                    case 'nw':
                        newWidth = Math.max(minWidth, startWidth - deltaX);
                        newHeight = Math.max(minHeight, startHeight - deltaY);
                        newLeft = startLeft + (startWidth - newWidth);
                        newTop = startTop + (startHeight - newHeight);
                        break;
                }
                
                const maxWidth = window.innerWidth - newLeft;
                const maxHeight = window.innerHeight - newTop;
                
                newWidth = Math.min(newWidth, maxWidth);
                newHeight = Math.min(newHeight, maxHeight);
                
                container.style.width = newWidth + 'px';
                container.style.height = newHeight + 'px';
                container.style.left = newLeft + 'px';
                container.style.top = newTop + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                isResizing = false;
                currentHandle = null;
            });
        })();

        window.addEventListener('load', function() {
            requestNotificationPermission();
            const savedUsername = loadUsername();
            if (savedUsername) {
                usernameInput.value = savedUsername;
                currentUser = savedUsername;
                if (wsReady) {
                    ws.send(savedUsername);
                }
            }
            loadInitialHistory();
            initVoiceChat();
        });
    </script>
</body>
</html>
